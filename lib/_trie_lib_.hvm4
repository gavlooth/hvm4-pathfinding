// _trie_lib_.hvm4 - Radix-16 trie (HAMT-style) library for HVM4.
// Filename starts with _ so the test runner skips it.
//
// Provides O(log16(V)) lookup and update for distance tables,
// replacing O(V) association lists. For V=1000, only 3 levels deep.
//
// Constructors:
//   #H{c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15}  — 16-way branch
//   #HL{val}                                                        — leaf node
//   #HE{}                                                           — empty/unset
//
// Functions:
//   @trie_empty         -> #HE{}
//   @trie_get(key, depth, trie)       -> value or @INF
//   @trie_set(key, val, depth, trie)  -> new trie with updated value
//   @trie_min_update(key, val, depth, trie) -> set only if val < current
//
// The depth parameter is ceil(log16(V)). Each level extracts 4 bits
// via key % 16 to select one of 16 children, then recurses with key / 16.
// After depth levels, we reach a leaf.
//
// HVM4 parser notes:
//   - λ{...}(expr) cannot appear as RHS of ! binding (use inline match instead)
//   - Variables used in multiple match arms must be declared with & for cloning

// ---------- empty trie ----------
@trie_empty = #HE{}

// ---------- trie_get: lookup key in trie, return value or @INF ----------

@trie_get = λ&key. λ&depth. λ{
  #HE: @INF;
  #HL: λval. val;
  #H: λc0.λc1.λc2.λc3.λc4.λc5.λc6.λc7.λc8.λc9.λc10.λc11.λc12.λc13.λc14.λc15.
    ! &slot = key % 16;
    ! &next = key / 16;
    ! &nd = depth - 1;
    λ{
      0:  @trie_get(next,nd,c0);  1:  @trie_get(next,nd,c1);
      2:  @trie_get(next,nd,c2);  3:  @trie_get(next,nd,c3);
      4:  @trie_get(next,nd,c4);  5:  @trie_get(next,nd,c5);
      6:  @trie_get(next,nd,c6);  7:  @trie_get(next,nd,c7);
      8:  @trie_get(next,nd,c8);  9:  @trie_get(next,nd,c9);
      10: @trie_get(next,nd,c10); 11: @trie_get(next,nd,c11);
      12: @trie_get(next,nd,c12); 13: @trie_get(next,nd,c13);
      14: @trie_get(next,nd,c14); λn. @trie_get(next,nd,c15)
    }(slot)
}

// ---------- trie_set: set key to val in trie, return new trie ----------

@trie_set = λ&key. λ&val. λ&depth. λ{
  #HL: λold. #HL{val};
  #HE: λ{
    0: #HL{val};
    λn.
      ! &slot = key % 16;
      ! &next = key / 16;
      ! &nd = depth - 1;
      ! &leaf = @trie_set(next, val, nd, #HE{});
      @trie_set_slot(slot, leaf)
  }(depth);
  #H: λ&c0.λ&c1.λ&c2.λ&c3.λ&c4.λ&c5.λ&c6.λ&c7.λ&c8.λ&c9.λ&c10.λ&c11.λ&c12.λ&c13.λ&c14.λ&c15.
    ! &slot = key % 16;
    ! &next = key / 16;
    ! &nd = depth - 1;
    λ{
      0:  #H{@trie_set(next,val,nd,c0),c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15};
      1:  #H{c0,@trie_set(next,val,nd,c1),c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15};
      2:  #H{c0,c1,@trie_set(next,val,nd,c2),c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15};
      3:  #H{c0,c1,c2,@trie_set(next,val,nd,c3),c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15};
      4:  #H{c0,c1,c2,c3,@trie_set(next,val,nd,c4),c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15};
      5:  #H{c0,c1,c2,c3,c4,@trie_set(next,val,nd,c5),c6,c7,c8,c9,c10,c11,c12,c13,c14,c15};
      6:  #H{c0,c1,c2,c3,c4,c5,@trie_set(next,val,nd,c6),c7,c8,c9,c10,c11,c12,c13,c14,c15};
      7:  #H{c0,c1,c2,c3,c4,c5,c6,@trie_set(next,val,nd,c7),c8,c9,c10,c11,c12,c13,c14,c15};
      8:  #H{c0,c1,c2,c3,c4,c5,c6,c7,@trie_set(next,val,nd,c8),c9,c10,c11,c12,c13,c14,c15};
      9:  #H{c0,c1,c2,c3,c4,c5,c6,c7,c8,@trie_set(next,val,nd,c9),c10,c11,c12,c13,c14,c15};
      10: #H{c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,@trie_set(next,val,nd,c10),c11,c12,c13,c14,c15};
      11: #H{c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,@trie_set(next,val,nd,c11),c12,c13,c14,c15};
      12: #H{c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,@trie_set(next,val,nd,c12),c13,c14,c15};
      13: #H{c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,@trie_set(next,val,nd,c13),c14,c15};
      14: #H{c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,@trie_set(next,val,nd,c14),c15};
      λn. #H{c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,@trie_set(next,val,nd,c15)}
    }(slot)
}

// ---------- trie_set_slot: create a fresh 16-way node with one child set ----------

@trie_set_slot = λ&slot. λ&child. λ{
  0:  #H{child,#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{}};
  1:  #H{#HE{},child,#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{}};
  2:  #H{#HE{},#HE{},child,#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{}};
  3:  #H{#HE{},#HE{},#HE{},child,#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{}};
  4:  #H{#HE{},#HE{},#HE{},#HE{},child,#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{}};
  5:  #H{#HE{},#HE{},#HE{},#HE{},#HE{},child,#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{}};
  6:  #H{#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},child,#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{}};
  7:  #H{#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},child,#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{}};
  8:  #H{#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},child,#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{}};
  9:  #H{#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},child,#HE{},#HE{},#HE{},#HE{},#HE{},#HE{}};
  10: #H{#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},child,#HE{},#HE{},#HE{},#HE{},#HE{}};
  11: #H{#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},child,#HE{},#HE{},#HE{},#HE{}};
  12: #H{#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},child,#HE{},#HE{},#HE{}};
  13: #H{#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},child,#HE{},#HE{}};
  14: #H{#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},child,#HE{}};
  λn. #H{#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},child}
}(slot)

// ---------- trie_min_update: set key to val only if val < current ----------

@trie_min_update = λ&key. λ&val. λ&depth. λ{
  #HL: λ&old. λ{0: #HL{old}; λn. #HL{val}}(val < old);
  #HE: λ{
    0: #HL{val};
    λn.
      ! &slot = key % 16;
      ! &next = key / 16;
      ! &nd = depth - 1;
      ! &leaf = @trie_min_update(next, val, nd, #HE{});
      @trie_set_slot(slot, leaf)
  }(depth);
  #H: λ&c0.λ&c1.λ&c2.λ&c3.λ&c4.λ&c5.λ&c6.λ&c7.λ&c8.λ&c9.λ&c10.λ&c11.λ&c12.λ&c13.λ&c14.λ&c15.
    ! &slot = key % 16;
    ! &next = key / 16;
    ! &nd = depth - 1;
    λ{
      0:  #H{@trie_min_update(next,val,nd,c0),c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15};
      1:  #H{c0,@trie_min_update(next,val,nd,c1),c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15};
      2:  #H{c0,c1,@trie_min_update(next,val,nd,c2),c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15};
      3:  #H{c0,c1,c2,@trie_min_update(next,val,nd,c3),c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15};
      4:  #H{c0,c1,c2,c3,@trie_min_update(next,val,nd,c4),c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15};
      5:  #H{c0,c1,c2,c3,c4,@trie_min_update(next,val,nd,c5),c6,c7,c8,c9,c10,c11,c12,c13,c14,c15};
      6:  #H{c0,c1,c2,c3,c4,c5,@trie_min_update(next,val,nd,c6),c7,c8,c9,c10,c11,c12,c13,c14,c15};
      7:  #H{c0,c1,c2,c3,c4,c5,c6,@trie_min_update(next,val,nd,c7),c8,c9,c10,c11,c12,c13,c14,c15};
      8:  #H{c0,c1,c2,c3,c4,c5,c6,c7,@trie_min_update(next,val,nd,c8),c9,c10,c11,c12,c13,c14,c15};
      9:  #H{c0,c1,c2,c3,c4,c5,c6,c7,c8,@trie_min_update(next,val,nd,c9),c10,c11,c12,c13,c14,c15};
      10: #H{c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,@trie_min_update(next,val,nd,c10),c11,c12,c13,c14,c15};
      11: #H{c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,@trie_min_update(next,val,nd,c11),c12,c13,c14,c15};
      12: #H{c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,@trie_min_update(next,val,nd,c12),c13,c14,c15};
      13: #H{c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,@trie_min_update(next,val,nd,c13),c14,c15};
      14: #H{c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,@trie_min_update(next,val,nd,c14),c15};
      λn. #H{c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,@trie_min_update(next,val,nd,c15)}
    }(slot)
}

// ==========================================================================
// Radix-32 variant using nested #H32{lo16, hi16}
// Depth 2 covers V ≤ 1024
// ==========================================================================

@trie32_get = λ&key. λ&depth. λ{
  #HE: @INF;
  #HL: λval. val;
  #H32: λ&lo. λ&hi.
    ! &slot = key % 32;
    ! &next = key / 32;
    ! &nd = depth - 1;
    λ{0:
      @trie32_get_h(next, nd, slot - 16, hi);
    λn.
      @trie32_get_h(next, nd, slot, lo)
    }(slot < 16)
}

@trie32_get_h = λ&next. λ&nd. λ&slot. λ{
  #HE: @INF;
  #H: λc0.λc1.λc2.λc3.λc4.λc5.λc6.λc7.λc8.λc9.λc10.λc11.λc12.λc13.λc14.λc15.
    λ{
      0:  @trie32_get(next,nd,c0);  1:  @trie32_get(next,nd,c1);
      2:  @trie32_get(next,nd,c2);  3:  @trie32_get(next,nd,c3);
      4:  @trie32_get(next,nd,c4);  5:  @trie32_get(next,nd,c5);
      6:  @trie32_get(next,nd,c6);  7:  @trie32_get(next,nd,c7);
      8:  @trie32_get(next,nd,c8);  9:  @trie32_get(next,nd,c9);
      10: @trie32_get(next,nd,c10); 11: @trie32_get(next,nd,c11);
      12: @trie32_get(next,nd,c12); 13: @trie32_get(next,nd,c13);
      14: @trie32_get(next,nd,c14); λn. @trie32_get(next,nd,c15)
    }(slot)
}

@trie32_set = λ&key. λ&val. λ&depth. λ{
  #HL: λold. #HL{val};
  #HE: λ{
    0: #HL{val};
    λn.
      ! &slot = key % 32;
      ! &next = key / 32;
      ! &nd = depth - 1;
      ! &leaf = @trie32_set(next, val, nd, #HE{});
      ! &lo_slot = slot % 16;
      ! &inner = @trie_set_slot(lo_slot, leaf);
      λ{0:
        #H32{#HE{}, inner};
      λn.
        #H32{inner, #HE{}}
      }(slot < 16)
  }(depth);
  #H32: λ&lo. λ&hi.
    ! &slot = key % 32;
    ! &next = key / 32;
    ! &nd = depth - 1;
    λ{0:
      #H32{lo, @trie32_set_h(next, val, nd, slot - 16, hi)};
    λn.
      #H32{@trie32_set_h(next, val, nd, slot, lo), hi}
    }(slot < 16)
}

@trie32_set_h = λ&next. λ&val. λ&nd. λ&slot. λ{
  #HE: @trie_set_slot(slot, @trie32_set(next, val, nd, #HE{}));
  #H: λ&c0.λ&c1.λ&c2.λ&c3.λ&c4.λ&c5.λ&c6.λ&c7.λ&c8.λ&c9.λ&c10.λ&c11.λ&c12.λ&c13.λ&c14.λ&c15.
    λ{
      0:  #H{@trie32_set(next,val,nd,c0),c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15};
      1:  #H{c0,@trie32_set(next,val,nd,c1),c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15};
      2:  #H{c0,c1,@trie32_set(next,val,nd,c2),c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15};
      3:  #H{c0,c1,c2,@trie32_set(next,val,nd,c3),c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15};
      4:  #H{c0,c1,c2,c3,@trie32_set(next,val,nd,c4),c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15};
      5:  #H{c0,c1,c2,c3,c4,@trie32_set(next,val,nd,c5),c6,c7,c8,c9,c10,c11,c12,c13,c14,c15};
      6:  #H{c0,c1,c2,c3,c4,c5,@trie32_set(next,val,nd,c6),c7,c8,c9,c10,c11,c12,c13,c14,c15};
      7:  #H{c0,c1,c2,c3,c4,c5,c6,@trie32_set(next,val,nd,c7),c8,c9,c10,c11,c12,c13,c14,c15};
      8:  #H{c0,c1,c2,c3,c4,c5,c6,c7,@trie32_set(next,val,nd,c8),c9,c10,c11,c12,c13,c14,c15};
      9:  #H{c0,c1,c2,c3,c4,c5,c6,c7,c8,@trie32_set(next,val,nd,c9),c10,c11,c12,c13,c14,c15};
      10: #H{c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,@trie32_set(next,val,nd,c10),c11,c12,c13,c14,c15};
      11: #H{c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,@trie32_set(next,val,nd,c11),c12,c13,c14,c15};
      12: #H{c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,@trie32_set(next,val,nd,c12),c13,c14,c15};
      13: #H{c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,@trie32_set(next,val,nd,c13),c14,c15};
      14: #H{c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,@trie32_set(next,val,nd,c14),c15};
      λn. #H{c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,@trie32_set(next,val,nd,c15)}
    }(slot)
}

// ==========================================================================
// Linear Binary Trie — O(log2(V)) with zero trie cloning
//
// The key insight: every trie operation consumes the trie linearly and
// rebuilds it, returning the trie alongside the result. No DUP nodes are
// ever created on the trie structure. Only integers (key, depth, val) are
// cloned via & (DUP-NUM: 0 heap allocation).
//
// Nodes:
//   #B{left, right}  — binary branch (arity 2)
//   #BL{val}          — leaf holding a value
//   #BE{}             — empty/unset position
//
// Depth = ceil(log2(V)). Each level uses key % 2 to select left (0) or
// right (1), then recurses with key / 2 and depth - 1.
// ==========================================================================

// ---------- btrie_get_lin: linear GET returning #P{val, rebuilt_trie} ----------
// Traverses to the leaf, reads the value, and rebuilds the path back up.
// The trie is consumed and returned — no cloning needed.
//
// Helper functions (_B) avoid putting l,r in multiple match arms, which
// would force &l/&r and clone trie subtrees (defeating linearity).

@btrie_get_lin = λ&key. λ&depth. λ{
  #BE: #P{@INF, #BE{}};
  #BL: λ&val. #P{val, #BL{val}};
  #B: λl. λr.
    ! bit = key % 2;
    ! next = key / 2;
    ! nd = depth - 1;
    @btrie_get_lin_B(bit, next, nd, l, r)
}

// bit=0: recurse left, keep right.  bit=1: recurse right, keep left.
// Each arm binds its own l,r via lambda — each used exactly once.
@btrie_get_lin_B = λ{
  0: λnext. λnd. λl. λr.
    λ{#P: λval. λnew_l. #P{val, #B{new_l, r}}}(@btrie_get_lin(next, nd, l));
  λn. λnext. λnd. λl. λr.
    λ{#P: λval. λnew_r. #P{val, #B{l, new_r}}}(@btrie_get_lin(next, nd, r))
}

// ---------- btrie_get: destructive GET (for final extraction only) ----------
// Consumes the trie without rebuilding. Use only when you don't need the
// trie afterwards (e.g. extracting results from @bf at the end).

@btrie_get = λ&key. λ&depth. λ{
  #BE: @INF;
  #BL: λval. val;
  #B: λl. λr.
    ! bit = key % 2;
    ! next = key / 2;
    ! nd = depth - 1;
    @btrie_get_B(bit, next, nd, l, r)
}

@btrie_get_B = λ{
  0: λnext. λnd. λl. λr. @btrie_get(next, nd, l);
  λn. λnext. λnd. λl. λr. @btrie_get(next, nd, r)
}

// ---------- btrie_set: linear SET ----------
// Creates or replaces a value at the given key. Builds path if needed.

@btrie_set = λ&key. λ&val. λ&depth. λ{
  #BL: λold. #BL{val};
  #BE: λ{
    0: #BL{val};
    λn.
      ! &bit = key % 2;
      ! &next = key / 2;
      ! &nd = depth - 1;
      @btrie_set_BE(bit, next, val, nd)
  }(depth);
  #B: λl. λr.
    ! bit = key % 2;
    ! next = key / 2;
    ! nd = depth - 1;
    @btrie_set_B(bit, next, val, nd, l, r)
}

@btrie_set_BE = λ{
  0: λnext. λval. λnd. #B{@btrie_set(next, val, nd, #BE{}), #BE{}};
  λn. λnext. λval. λnd. #B{#BE{}, @btrie_set(next, val, nd, #BE{})}
}

@btrie_set_B = λ{
  0: λnext. λval. λnd. λl. λr. #B{@btrie_set(next, val, nd, l), r};
  λn. λnext. λval. λnd. λl. λr. #B{l, @btrie_set(next, val, nd, r)}
}

// ---------- btrie_min_update: linear MIN-UPDATE ----------
// Sets key to val only if val < current value. If the slot is empty (#BE),
// inserts unconditionally. Linear in trie structure.

@btrie_min_update = λ&key. λ&val. λ&depth. λ{
  #BL: λ&old. λ{0: #BL{old}; λn. #BL{val}}(val < old);
  #BE: λ{
    0: #BL{val};
    λn.
      ! &bit = key % 2;
      ! &next = key / 2;
      ! &nd = depth - 1;
      @btrie_mu_BE(bit, next, val, nd)
  }(depth);
  #B: λl. λr.
    ! bit = key % 2;
    ! next = key / 2;
    ! nd = depth - 1;
    @btrie_mu_B(bit, next, val, nd, l, r)
}

@btrie_mu_BE = λ{
  0: λnext. λval. λnd. #B{@btrie_min_update(next, val, nd, #BE{}), #BE{}};
  λn. λnext. λval. λnd. #B{#BE{}, @btrie_min_update(next, val, nd, #BE{})}
}

@btrie_mu_B = λ{
  0: λnext. λval. λnd. λl. λr. #B{@btrie_min_update(next, val, nd, l), r};
  λn. λnext. λval. λnd. λl. λr. #B{l, @btrie_min_update(next, val, nd, r)}
}

// ---------- Linear Bellman-Ford helpers ----------
// These versions do NOT clone the distance trie (no &dist, no &x, no &acc).
// Only the function reference &f is cloned (cheap: just a book thunk).

@foldl_lin = λf. λacc. λlist. @foldl_go(list, f, acc)

@foldl_go = λ{
  []: λf. λacc. acc;
  <>: λh. λt. λ&f. λacc. @foldl_go(t, f, f(acc, h))
}

@repeat_lin = λf. λx. λn. @repeat_go(n, f, x)

@repeat_go = λ{
  0: λf. λx. x;
  λn. λ&f. λx. @repeat_go(n - 1, f, f(x))
}

// ---------- relax_edge_lin: fully linear edge relaxation ----------
// 1. btrie_get_lin(u, dist) → #P{du, dist2}  (consumes dist, returns rebuilt)
// 2. If du < INF, btrie_min_update(v, du+w, dist2)  (consumes dist2)
// 3. If du >= INF, return dist2 unchanged
//
// Zero DUP nodes on the trie. Only integers cloned via &.

@relax_edge_lin = λdist. λ{
  #E3: λu. λv. λw.
    λ{#P: λ&du. λdist2.
      ! new_d = du + w;
      @relax_cond(du < @INF, v, new_d, dist2)
    }(@btrie_get_lin(u, @DEPTH, dist))
}

// Each arm binds its own v, new_d, dist via lambda — dist used once per arm.
@relax_cond = λ{
  0: λv. λnew_d. λdist. dist;
  λn. λv. λnew_d. λdist. @btrie_min_update(v, new_d, @DEPTH, dist)
}

@relax_round_lin = λdist. @foldl_lin(@relax_edge_lin, dist, @edges)

// ==========================================================================
// Early Termination Bellman-Ford (linear binary trie)
//
// Instead of always running V-1 rounds, track whether any distance changed
// in each round. Stop when no changes occur (graph has converged).
// For sparse graphs, this converges in ~diameter rounds (often 5-20),
// not V-1 rounds. This is the key to making V=1000 fit in memory.
//
// New data structures:
//   #S{dist, changed}  — state: distance trie + change counter (uint)
//
// New function:
//   btrie_min_update_f  — like btrie_min_update but returns #P{trie, 0_or_1}
//                         indicating whether a change was made
// ==========================================================================

// ---------- btrie_min_update_f: linear MIN-UPDATE with change flag ----------
// Returns #P{new_trie, changed} where changed is 0 (no change) or 1 (updated).

@btrie_min_update_f = λ&key. λ&val. λ&depth. λ{
  #BL: λ&old. λ{0: #P{#BL{old}, 0}; λn. #P{#BL{val}, 1}}(val < old);
  #BE: λ{
    0: #P{#BL{val}, 1};
    λn.
      ! &bit = key % 2;
      ! &next = key / 2;
      ! &nd = depth - 1;
      @btrie_muf_BE(bit, next, val, nd)
  }(depth);
  #B: λl. λr.
    ! bit = key % 2;
    ! next = key / 2;
    ! nd = depth - 1;
    @btrie_muf_B(bit, next, val, nd, l, r)
}

@btrie_muf_BE = λ{
  0: λnext. λval. λnd.
    λ{#P: λchild. λc. #P{#B{child, #BE{}}, c}}(@btrie_min_update_f(next, val, nd, #BE{}));
  λn. λnext. λval. λnd.
    λ{#P: λchild. λc. #P{#B{#BE{}, child}, c}}(@btrie_min_update_f(next, val, nd, #BE{}))
}

@btrie_muf_B = λ{
  0: λnext. λval. λnd. λl. λr.
    λ{#P: λnew_l. λc. #P{#B{new_l, r}, c}}(@btrie_min_update_f(next, val, nd, l));
  λn. λnext. λval. λnd. λl. λr.
    λ{#P: λnew_r. λc. #P{#B{l, new_r}, c}}(@btrie_min_update_f(next, val, nd, r))
}

// ---------- Early termination edge relaxation ----------
// Each edge relax: unpack #S{dist, changed}, relax, repack with updated count.

@relax_edge_et = λ{
  #S: λdist. λ&changed. λ{
    #E3: λu. λv. λw.
      λ{#P: λ&du. λdist2.
        ! new_d = du + w;
        @relax_cond_et(du < @INF, v, new_d, dist2, changed)
      }(@btrie_get_lin(u, @DEPTH, dist))
  }
}

@relax_cond_et = λ{
  0: λv. λnew_d. λdist. λchanged. #S{dist, changed};
  λn. λv. λnew_d. λdist. λ&changed.
    λ{#P: λnew_dist. λc. #S{new_dist, changed + c}}(@btrie_min_update_f(v, new_d, @DEPTH, dist))
}

// ---------- Early termination fold and round ----------

@foldl_et = λf. λacc. λlist. @foldl_et_go(list, f, acc)

@foldl_et_go = λ{
  []: λf. λacc. acc;
  <>: λh. λt. λ&f. λacc. @foldl_et_go(t, f, f(acc, h))
}

@relax_round_et = λ{
  #S: λdist. λold_changed.
    @foldl_et(@relax_edge_et, #S{dist, 0}, @edges)
}

// ---------- repeat_until: stop when changed == 0 ----------

@repeat_until = λf. λx. λn. @repeat_until_go(n, f, x)

@repeat_until_go = λ{
  0: λf. λx. x;
  λn. λ&f. λstate.
    @check_continue(n, f, f(state))
}

@check_continue = λ&n. λ&f. λ{
  #S: λdist. λchanged.
    @check_go(changed, n, f, dist)
}

@check_go = λ{
  0: λn. λf. λdist. #S{dist, 0};
  λm. λn. λf. λdist. @repeat_until_go(n - 1, f, #S{dist, 1})
}
