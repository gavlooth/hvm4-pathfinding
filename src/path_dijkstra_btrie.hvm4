// Dijkstra SSSP using linear binary trie + leftist heap priority queue.
//
// O((V+E) log V) instead of Bellman-Ford's O(V*E).
// Uses lazy deletion: stale PQ entries (where popped distance > current dist)
// are simply skipped.
//
// Graph (5 nodes, directed, weighted — same as Bellman-Ford tests):
//   0 -> 1 (weight 4)
//   0 -> 2 (weight 2)
//   1 -> 3 (weight 3)
//   2 -> 1 (weight 1)
//   2 -> 3 (weight 5)
//   3 -> 4 (weight 1)
//
// Shortest distances from source node 0:
//   dist[0] = 0
//   dist[1] = 3  (0->2->1: 2+1)
//   dist[2] = 2  (0->2)
//   dist[3] = 6  (0->2->1->3: 2+1+3)
//   dist[4] = 7  (0->2->1->3->4: 2+1+3+1)
//
// DEPTH = 3 (ceil(log2(5)) = 3, since 2^3 = 8 >= 5)

// ===== constants =====

@INF = 999999
@DEPTH = 3

// ===== linear binary trie =====
// Copied inline since #include is not supported for standalone files.

// --- btrie_get_lin: linear GET returning #P{val, rebuilt_trie} ---

@btrie_get_lin = λ&key. λ&depth. λ{
  #BE: #P{@INF, #BE{}};
  #BL: λ&val. #P{val, #BL{val}};
  #B: λl. λr.
    ! bit = key % 2;
    ! next = key / 2;
    ! nd = depth - 1;
    @btrie_get_lin_B(bit, next, nd, l, r)
}

@btrie_get_lin_B = λ{
  0: λnext. λnd. λl. λr.
    λ{#P: λval. λnew_l. #P{val, #B{new_l, r}}}(@btrie_get_lin(next, nd, l));
  λn. λnext. λnd. λl. λr.
    λ{#P: λval. λnew_r. #P{val, #B{l, new_r}}}(@btrie_get_lin(next, nd, r))
}

// --- btrie_get: destructive GET (for final extraction only) ---

@btrie_get = λ&key. λ&depth. λ{
  #BE: @INF;
  #BL: λval. val;
  #B: λl. λr.
    ! bit = key % 2;
    ! next = key / 2;
    ! nd = depth - 1;
    @btrie_get_B(bit, next, nd, l, r)
}

@btrie_get_B = λ{
  0: λnext. λnd. λl. λr. @btrie_get(next, nd, l);
  λn. λnext. λnd. λl. λr. @btrie_get(next, nd, r)
}

// --- btrie_set: linear SET ---

@btrie_set = λ&key. λ&val. λ&depth. λ{
  #BL: λold. #BL{val};
  #BE: λ{
    0: #BL{val};
    λn.
      ! &bit = key % 2;
      ! &next = key / 2;
      ! &nd = depth - 1;
      @btrie_set_BE(bit, next, val, nd)
  }(depth);
  #B: λl. λr.
    ! bit = key % 2;
    ! next = key / 2;
    ! nd = depth - 1;
    @btrie_set_B(bit, next, val, nd, l, r)
}

@btrie_set_BE = λ{
  0: λnext. λval. λnd. #B{@btrie_set(next, val, nd, #BE{}), #BE{}};
  λn. λnext. λval. λnd. #B{#BE{}, @btrie_set(next, val, nd, #BE{})}
}

@btrie_set_B = λ{
  0: λnext. λval. λnd. λl. λr. #B{@btrie_set(next, val, nd, l), r};
  λn. λnext. λval. λnd. λl. λr. #B{l, @btrie_set(next, val, nd, r)}
}

// ===== leftist heap priority queue =====

@pq_empty = #PQE{}

@pq_rank = λ{
  #PQE: 0;
  #PQN: λp.λv.λl.λr.λk. k
}

@pq_make = λ&prio.λ&val.λ&left.λ&right.
  ! &lr = @pq_rank(left)
  ! &rr = @pq_rank(right)
  λ{0:
    #PQN{prio, val, right, left, lr + 1};
  λn.
    #PQN{prio, val, left, right, rr + 1}
  }(lr >= rr)

@pq_merge = λ{
  #PQE: λb. b;
  #PQN: λ&ap.λ&av.λ&al.λ&ar.λ&ak. λ{
    #PQE: #PQN{ap, av, al, ar, ak};
    #PQN: λ&bp.λ&bv.λ&bl.λ&br.λ&bk.
      λ{0:
        @pq_make(bp, bv, bl, @pq_merge(#PQN{ap, av, al, ar, ak}, br));
      λn.
        @pq_make(ap, av, al, @pq_merge(ar, #PQN{bp, bv, bl, br, bk}))
      }(ap <= bp)
  }
}

@pq_insert = λprio.λval.λheap.
  @pq_merge(#PQN{prio, val, #PQE{}, #PQE{}, 1}, heap)

@pq_pop = λ{
  #PQE: #PQE{};
  #PQN: λp.λv.λl.λr.λk. #R{p, v, @pq_merge(l, r)}
}

// ===== adjacency list stored in btrie =====
// Each node maps to a list of #P{neighbor, weight} pairs.
// We use a separate linear get that returns [] for missing entries
// instead of @INF.

@adj_get_lin = λ&key. λ&depth. λ{
  #BE: #P{[], #BE{}};
  #BL: λ&val. #P{val, #BL{val}};
  #B: λl. λr.
    ! bit = key % 2;
    ! next = key / 2;
    ! nd = depth - 1;
    @adj_get_lin_B(bit, next, nd, l, r)
}

@adj_get_lin_B = λ{
  0: λnext. λnd. λl. λr.
    λ{#P: λval. λnew_l. #P{val, #B{new_l, r}}}(@adj_get_lin(next, nd, l));
  λn. λnext. λnd. λl. λr.
    λ{#P: λval. λnew_r. #P{val, #B{l, new_r}}}(@adj_get_lin(next, nd, r))
}

// Build adjacency trie: node -> list of #P{neighbor, weight}
@adj_trie =
  @btrie_set(0, [#P{1,4}, #P{2,2}], @DEPTH,
  @btrie_set(1, [#P{3,3}], @DEPTH,
  @btrie_set(2, [#P{1,1}, #P{3,5}], @DEPTH,
  @btrie_set(3, [#P{4,1}], @DEPTH,
  @btrie_set(4, [], @DEPTH, #BE{})))))

// ===== Dijkstra algorithm =====

// State: #DS{adj_trie, dist_trie, pq}
// We thread the adj_trie through linearly as well.

// --- dijkstra: main loop ---
// Pop from PQ, check if stale, process or skip.

@dijkstra = λ{
  #DS: λadj. λdist. λpq.
    @dijk_pop(@pq_pop(pq), adj, dist)
}

// Handle PQ pop result: empty (#PQE) or result (#R)
// The pop-result is matched first; adj and dist are bound per-arm
// to avoid linearity violations (each arm uses them exactly once).
@dijk_pop = λ{
  #PQE: λadj. λdist. #DS{adj, dist, @pq_empty};
  #R: λd. λu. λrest. λadj. λdist.
    @dijk_check(adj, dist, rest, d, u)
}

// Get dist[u] linearly, then check if stale
@dijk_check = λadj. λdist. λpq. λ&d. λ&u.
  λ{#P: λ&du. λdist2.
    @dijk_stale(d > du, adj, dist2, pq, d, u)
  }(@btrie_get_lin(u, @DEPTH, dist))

// If d > du, skip (stale entry). Otherwise process node u.
// Helper function to avoid putting adj, dist2, pq in multiple match arms.
@dijk_stale = λ{
  0: λadj. λdist. λpq. λd. λu.
    // d == du (not stale): process this node
    @dijk_process(adj, dist, pq, d, u);
  λn. λadj. λdist. λpq. λd. λu.
    // d > du (stale): skip, recurse
    @dijkstra(#DS{adj, dist, pq})
}

// Process node u: get its adjacency list, relax all neighbors
@dijk_process = λadj. λdist. λpq. λ&d. λu.
  λ{#P: λneighbors. λadj2.
    @dijk_relax_then_recurse(adj2, dist, pq, d, neighbors)
  }(@adj_get_lin(u, @DEPTH, adj))

// Relax all neighbors, then recurse into dijkstra
@dijk_relax_then_recurse = λadj. λdist. λpq. λd. λneighbors.
  λ{#DS2: λdist2. λpq2.
    @dijkstra(#DS{adj, dist2, pq2})
  }(@relax_all(d, neighbors, dist, pq))

// --- relax_all: fold over neighbor list, threading (dist, pq) ---
// Returns #DS2{dist, pq}

@relax_all = λd. λneighbors. λdist. λpq.
  @relax_fold(neighbors, d, dist, pq)

@relax_fold = λ{
  []: λd. λdist. λpq. #DS2{dist, pq};
  <>: λh. λt. λ&d. λdist. λpq.
    λ{#P: λ&v. λ&w.
      @relax_one_then_continue(t, d, v, d + w, dist, pq)
    }(h)
}

// Relax edge (u -> v) with weight w. new_d = d + w.
// Get dist[v] linearly, compare, maybe update.
@relax_one_then_continue = λt. λd. λ&v. λ&new_d. λdist. λpq.
  λ{#P: λ&dv. λdist2.
    @relax_decide(new_d < dv, t, d, v, new_d, dv, dist2, pq)
  }(@btrie_get_lin(v, @DEPTH, dist))

// If new_d < dv: update dist[v] and insert into PQ.
// Otherwise: pass through unchanged.
@relax_decide = λ{
  0: λt. λd. λv. λnew_d. λdv. λdist. λpq.
    // new_d >= dv: no improvement, continue with rest
    @relax_fold(t, d, dist, pq);
  λn. λt. λd. λ&v. λ&new_d. λdv. λdist. λpq.
    // new_d < dv: update dist[v] = new_d, insert (new_d, v) into PQ
    ! dist2 = @btrie_set(v, new_d, @DEPTH, dist);
    ! pq2 = @pq_insert(new_d, v, pq);
    @relax_fold(t, d, dist2, pq2)
}

// ===== initial state =====

// dist[0] = 0 (source), all others = INF (implicitly, via #BE{})
@init_dist = @btrie_set(0, 0, @DEPTH, #BE{})

// PQ starts with (0, node 0)
@init_pq = @pq_insert(0, 0, @pq_empty)

// Full initial state
@init = #DS{@adj_trie, @init_dist, @init_pq}

// ===== run Dijkstra =====

@result = @dijkstra(@init)

// ===== extract results =====

@extract = λ{#DS: λadj. λdist. λpq.
  λ{#P: λ&d0. λdist.
  λ{#P: λ&d1. λdist.
  λ{#P: λ&d2. λdist.
  λ{#P: λ&d3. λdist.
    ! d4 = @btrie_get(4, @DEPTH, dist);
    [d0, d1, d2, d3, d4]
  }(@btrie_get_lin(3, @DEPTH, dist))
  }(@btrie_get_lin(2, @DEPTH, dist))
  }(@btrie_get_lin(1, @DEPTH, dist))
  }(@btrie_get_lin(0, @DEPTH, dist))
}

@main = @extract(@result)
//[0,3,2,6,7]
