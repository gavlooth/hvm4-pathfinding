// Parallel Prefix Scan (Blelloch-style, Bend-emitted)
//
// Tree-parallel exclusive scan using divide-and-conquer.
// Input: balanced binary tree of depth d holds 2^d elements.
// Output: list of exclusive prefix sums.
//
// Trees use list encoding: leaf = [val], node = [left, right]
//
// IMPORTANT: HVM4 λ{0:...; λn. ...} does NOT decrement n.
// Must use explicit (n - 1) for recursion depth.
//
// Usage: HVM4/clang/main src/alg_prefix_scan.hvm4 -s

// ---- Build input tree: depth d, values 1..2^d ----
// Leaf = [val], Node = [left_subtree, right_subtree]

@build = λ&depth. λ&offset.
  λ{
    0: (offset + 1) <> [];
    λn.
      ! &d1 = depth - 1;
      ! &l = @build(d1, offset * 2);
      ! &r = @build(d1, offset * 2 + 1);
      l <> r <> []
  }(depth)

// ---- Sum all leaves in a tree ----

@tree_sum = λ&depth. λ&tree.
  λ{
    0: λ{<>: λval. λnil. val}(tree);
    λn.
      ! &d1 = depth - 1;
      λ{<>: λ&left. λ&rest. λ{<>: λ&right. λnil.
        @tree_sum(d1, left) + @tree_sum(d1, right)
      }(rest)}(tree)
  }(depth)

// ---- Prefix scan: returns list of exclusive prefixes ----

@prefix = λ&depth. λ&pfx. λ&tree.
  λ{
    0: pfx <> [];
    λn.
      ! &d1 = depth - 1;
      λ{<>: λ&left. λrest. λ{<>: λ&right. λnil.
        ! &lsum = @tree_sum(d1, left);
        @append(@prefix(d1, pfx, left), @prefix(d1, pfx + lsum, right))
      }(rest)}(tree)
  }(depth)

// ---- Flatten tree to list ----

@flatten = λ&depth. λ&tree.
  λ{
    0: λ{<>: λval. λnil. val <> []}(tree);
    λn.
      ! &d1 = depth - 1;
      λ{<>: λleft. λrest. λ{<>: λright. λnil.
        @append(@flatten(d1, left), @flatten(d1, right))
      }(rest)}(tree)
  }(depth)

@append = λ{
  []: λys. ys;
  <>: λh. λt. λys. h <> @append(t, ys)
}

// ---- Full scan ----

@scan = λ&depth.
  ! &input = @build(depth, 0);
  @prefix(depth, 0, input)

// ---- Test depth=2 (4 elements: [1,2,3,4]) ----

@main = @scan(2)
// Input:  [1, 2, 3, 4]
// Expected: [0, 1, 3, 6]  (exclusive prefix sums)
