// Bellman-Ford SSSP using linear binary trie with EARLY TERMINATION.
//
// Same 5-node graph as path_bellman_ford_btrie.hvm4 but stops iterating
// when no distances change in a round. For sparse graphs this converges
// in ~diameter rounds (here: 4), not V-1 rounds.
//
// The key innovation: btrie_min_update_f returns #P{trie, changed_flag}
// so we can track whether any update occurred per round. When changed==0,
// repeat_until stops early.
//
// Graph (5 nodes, directed, weighted):
//   0 -> 1 (weight 4)
//   0 -> 2 (weight 2)
//   1 -> 3 (weight 3)
//   2 -> 1 (weight 1)
//   2 -> 3 (weight 5)
//   3 -> 4 (weight 1)
//
// Shortest distances from source node 0:
//   dist[0] = 0
//   dist[1] = 3  (0->2->1: 2+1)
//   dist[2] = 2  (0->2)
//   dist[3] = 6  (0->2->1->3: 2+1+3)
//   dist[4] = 7  (0->2->1->3->4: 2+1+3+1)
//
// DEPTH = 3 (ceil(log2(5)) = 3, since 2^3 = 8 >= 5)

// ---- constants ----

@INF = 999999
@DEPTH = 3

// ---- linear binary trie (same as btrie variant) ----

@btrie_get_lin = λ&key. λ&depth. λ{
  #BE: #P{@INF, #BE{}};
  #BL: λ&val. #P{val, #BL{val}};
  #B: λl. λr.
    ! bit = key % 2;
    ! next = key / 2;
    ! nd = depth - 1;
    @btrie_get_lin_B(bit, next, nd, l, r)
}

@btrie_get_lin_B = λ{
  0: λnext. λnd. λl. λr.
    λ{#P: λval. λnew_l. #P{val, #B{new_l, r}}}(@btrie_get_lin(next, nd, l));
  λn. λnext. λnd. λl. λr.
    λ{#P: λval. λnew_r. #P{val, #B{l, new_r}}}(@btrie_get_lin(next, nd, r))
}

@btrie_get = λ&key. λ&depth. λ{
  #BE: @INF;
  #BL: λval. val;
  #B: λl. λr.
    ! bit = key % 2;
    ! next = key / 2;
    ! nd = depth - 1;
    @btrie_get_B(bit, next, nd, l, r)
}

@btrie_get_B = λ{
  0: λnext. λnd. λl. λr. @btrie_get(next, nd, l);
  λn. λnext. λnd. λl. λr. @btrie_get(next, nd, r)
}

@btrie_set = λ&key. λ&val. λ&depth. λ{
  #BL: λold. #BL{val};
  #BE: λ{
    0: #BL{val};
    λn.
      ! &bit = key % 2;
      ! &next = key / 2;
      ! &nd = depth - 1;
      @btrie_set_BE(bit, next, val, nd)
  }(depth);
  #B: λl. λr.
    ! bit = key % 2;
    ! next = key / 2;
    ! nd = depth - 1;
    @btrie_set_B(bit, next, val, nd, l, r)
}

@btrie_set_BE = λ{
  0: λnext. λval. λnd. #B{@btrie_set(next, val, nd, #BE{}), #BE{}};
  λn. λnext. λval. λnd. #B{#BE{}, @btrie_set(next, val, nd, #BE{})}
}

@btrie_set_B = λ{
  0: λnext. λval. λnd. λl. λr. #B{@btrie_set(next, val, nd, l), r};
  λn. λnext. λval. λnd. λl. λr. #B{l, @btrie_set(next, val, nd, r)}
}

// ---- btrie_min_update_f: returns #P{trie, changed_flag} ----

@btrie_min_update_f = λ&key. λ&val. λ&depth. λ{
  #BL: λ&old. λ{0: #P{#BL{old}, 0}; λn. #P{#BL{val}, 1}}(val < old);
  #BE: λ{
    0: #P{#BL{val}, 1};
    λn.
      ! &bit = key % 2;
      ! &next = key / 2;
      ! &nd = depth - 1;
      @btrie_muf_BE(bit, next, val, nd)
  }(depth);
  #B: λl. λr.
    ! bit = key % 2;
    ! next = key / 2;
    ! nd = depth - 1;
    @btrie_muf_B(bit, next, val, nd, l, r)
}

@btrie_muf_BE = λ{
  0: λnext. λval. λnd.
    λ{#P: λchild. λc. #P{#B{child, #BE{}}, c}}(@btrie_min_update_f(next, val, nd, #BE{}));
  λn. λnext. λval. λnd.
    λ{#P: λchild. λc. #P{#B{#BE{}, child}, c}}(@btrie_min_update_f(next, val, nd, #BE{}))
}

@btrie_muf_B = λ{
  0: λnext. λval. λnd. λl. λr.
    λ{#P: λnew_l. λc. #P{#B{new_l, r}, c}}(@btrie_min_update_f(next, val, nd, l));
  λn. λnext. λval. λnd. λl. λr.
    λ{#P: λnew_r. λc. #P{#B{l, new_r}, c}}(@btrie_min_update_f(next, val, nd, r))
}

// ---- edge list ----

@edges = [#E3{0,1,4}, #E3{0,2,2}, #E3{1,3,3}, #E3{2,1,1}, #E3{2,3,5}, #E3{3,4,1}]

// ---- early termination relaxation ----

@relax_edge_et = λ{
  #S: λdist. λ&changed. λ{
    #E3: λu. λv. λw.
      λ{#P: λ&du. λdist2.
        ! new_d = du + w;
        @relax_cond_et(du < @INF, v, new_d, dist2, changed)
      }(@btrie_get_lin(u, @DEPTH, dist))
  }
}

@relax_cond_et = λ{
  0: λv. λnew_d. λdist. λchanged. #S{dist, changed};
  λn. λv. λnew_d. λdist. λ&changed.
    λ{#P: λnew_dist. λc. #S{new_dist, changed + c}}(@btrie_min_update_f(v, new_d, @DEPTH, dist))
}

@foldl_et = λf. λacc. λlist. @foldl_et_go(list, f, acc)

@foldl_et_go = λ{
  []: λf. λacc. acc;
  <>: λh. λt. λ&f. λacc. @foldl_et_go(t, f, f(acc, h))
}

@relax_round_et = λ{
  #S: λdist. λold_changed.
    @foldl_et(@relax_edge_et, #S{dist, 0}, @edges)
}

@repeat_until = λf. λx. λn. @repeat_until_go(n, f, x)

@repeat_until_go = λ{
  0: λf. λx. x;
  λn. λ&f. λstate.
    @check_continue(n, f, f(state))
}

@check_continue = λ&n. λ&f. λ{
  #S: λdist. λchanged.
    @check_go(changed, n, f, dist)
}

@check_go = λ{
  0: λn. λf. λdist. #S{dist, 0};
  λm. λn. λf. λdist. @repeat_until_go(n - 1, f, %compact(#S{dist, 1}))
}

// ---- initial state: dist[0]=0, changed=1 (to start first round) ----

@init_dist = @btrie_set(0, 0, @DEPTH, #BE{})
@init_state = #S{@init_dist, 1}

// ---- run: max 4 rounds (V-1), but will stop early if no changes ----

@bf = @repeat_until(@relax_round_et, @init_state, 4)

// ---- extract results (chain linear gets to avoid cloning dist) ----

@extract = λ{#S: λdist. λc.
  λ{#P: λ&d0. λdist.
  λ{#P: λ&d1. λdist.
  λ{#P: λ&d2. λdist.
  λ{#P: λ&d3. λdist.
    ! d4 = @btrie_get(4, @DEPTH, dist);
    [d0, d1, d2, d3, d4]
  }(@btrie_get_lin(3, @DEPTH, dist))
  }(@btrie_get_lin(2, @DEPTH, dist))
  }(@btrie_get_lin(1, @DEPTH, dist))
  }(@btrie_get_lin(0, @DEPTH, dist))
}

@main = @extract(@bf)
//[0,3,2,6,7]
