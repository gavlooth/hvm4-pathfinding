// Algebraic shortest paths via tropical semiring (min, +) matrix squaring.
//
// Tropical semiring operations:
//   trop_add(a, b) = min(a, b)         ("addition" in the semiring)
//   trop_mul(a, b) = a + b with INF    ("multiplication" in the semiring)
//
// All-pairs shortest paths (APSP) via matrix exponentiation:
//   D^2 under the tropical semiring gives shortest paths through
//   at most one intermediate node. For 3 nodes this suffices.
//
// Graph (3 nodes, undirected, weighted):
//   0-1: weight 2
//   1-2: weight 3
//   0-2: weight 8
//
// Initial distance matrix D:
//   [[0, 2, 8],
//    [2, 0, 3],
//    [8, 3, 0]]
//
// Expected APSP result (D^2 tropical):
//   [[0, 2, 5],
//    [2, 0, 3],
//    [5, 3, 0]]
// (0->2 via 1: 2+3=5 < 8)

// --- Tropical semiring primitives ---

@INF = 999999

// trop_add(a, b) = min(a, b)
@trop_add = λ&a. λ&b. λ{0: b; λn. a}(a < b)

// trop_mul(a, b) = a + b, but INF if either operand is INF
@trop_mul = λ&a. λ&b.
  λ{0: λ{0: a + b; λn. @INF}(b == @INF); λn. @INF}(a == @INF)

// --- List utilities ---

// map(f, xs): apply f to each element
@map = λ&f. λ{[]: []; <>: λh. λt. f(h) <> @map(f, t)}

// foldl(f, acc, xs): left fold
@foldl = λ&f. λ&acc. λ{[]: acc; <>: λh. λt. @foldl(f, f(acc, h), t)}

// zip_with(f, xs, ys): combine two lists pairwise
@zip_with = λ&f. λxs. λys.
  λ{[]: []; <>: λhx. λtx.
    λ{[]: []; <>: λhy. λty. f(hx, hy) <> @zip_with(f, tx, ty)}(ys)
  }(xs)

// nth(n, xs): get the nth element (0-indexed)
@nth = λ&n. λ{[]: 0; <>: λ&h. λt. λ{0: h; λm. @nth(n - 1, t)}(n)}

// col(j, mat): extract column j from a matrix (list of rows)
@col = λ&j. λ{[]: []; <>: λ&row. λt. @nth(j, row) <> @col(j, t)}

// --- Tropical dot product ---

// dot(row, col) = foldl(trop_add, INF, zip_with(trop_mul, row, col))
@dot = λ&row. λ&col.
  @foldl(λ&a. λb. @trop_add(a, b), @INF, @zip_with(λa. λb. @trop_mul(a, b), row, col))

// --- Tropical matrix multiply (3x3) ---

// mat_mul(a, b): tropical matrix product
// Extracts columns of b, then for each row of a computes dot product
// with each column.
@mat_mul = λ&a. λ&b.
  ! &c0 = @col(0, b);
  ! &c1 = @col(1, b);
  ! &c2 = @col(2, b);
  @map(λ&r. [@dot(r, c0), @dot(r, c1), @dot(r, c2)], a)

// --- Distance matrix ---

@D = [
  [0, 2, 8],
  [2, 0, 3],
  [8, 3, 0]
]

// Compute D^2 under tropical semiring = APSP for 3 nodes
@main = @mat_mul(@D, @D)
//[[0,2,5],[2,0,3],[5,3,0]]
