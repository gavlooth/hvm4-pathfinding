// Contraction Hierarchy query using radix-32 trie distance tables.
//
// Same graph as path_contraction_hierarchy_trie.hvm4 but uses radix-32
// (#H32{lo,hi} wrapping two #H{...} nodes) for benchmarking.
//
// Graph (6 nodes, ranks 0..5):
// Shortest path from 0 to 5 = 10.
//
// DEPTH = 1 (ceil(log32(6)) = 1)

// ---- constants ----

@INF = 999999
@DEPTH = 1

// ---- trie_set_slot ----

@trie_set_slot = λ&slot. λ&child. λ{
  0:  #H{child,#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{}};
  1:  #H{#HE{},child,#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{}};
  2:  #H{#HE{},#HE{},child,#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{}};
  3:  #H{#HE{},#HE{},#HE{},child,#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{}};
  4:  #H{#HE{},#HE{},#HE{},#HE{},child,#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{}};
  5:  #H{#HE{},#HE{},#HE{},#HE{},#HE{},child,#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{}};
  6:  #H{#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},child,#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{}};
  7:  #H{#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},child,#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{}};
  8:  #H{#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},child,#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{}};
  9:  #H{#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},child,#HE{},#HE{},#HE{},#HE{},#HE{},#HE{}};
  10: #H{#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},child,#HE{},#HE{},#HE{},#HE{},#HE{}};
  11: #H{#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},child,#HE{},#HE{},#HE{},#HE{}};
  12: #H{#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},child,#HE{},#HE{},#HE{}};
  13: #H{#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},child,#HE{},#HE{}};
  14: #H{#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},child,#HE{}};
  λn. #H{#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},child}
}(slot)

// ---- radix-32 trie ----

@trie32_get = λ&key. λ&depth. λ{
  #HE: @INF;
  #HL: λval. val;
  #H32: λ&lo. λ&hi.
    ! &slot = key % 32;
    ! &next = key / 32;
    ! &nd = depth - 1;
    λ{0:
      @trie32_get_h(next, nd, slot - 16, hi);
    λn.
      @trie32_get_h(next, nd, slot, lo)
    }(slot < 16)
}

@trie32_get_h = λ&next. λ&nd. λ&slot. λ{
  #HE: @INF;
  #H: λc0.λc1.λc2.λc3.λc4.λc5.λc6.λc7.λc8.λc9.λc10.λc11.λc12.λc13.λc14.λc15.
    λ{
      0:  @trie32_get(next,nd,c0);  1:  @trie32_get(next,nd,c1);
      2:  @trie32_get(next,nd,c2);  3:  @trie32_get(next,nd,c3);
      4:  @trie32_get(next,nd,c4);  5:  @trie32_get(next,nd,c5);
      6:  @trie32_get(next,nd,c6);  7:  @trie32_get(next,nd,c7);
      8:  @trie32_get(next,nd,c8);  9:  @trie32_get(next,nd,c9);
      10: @trie32_get(next,nd,c10); 11: @trie32_get(next,nd,c11);
      12: @trie32_get(next,nd,c12); 13: @trie32_get(next,nd,c13);
      14: @trie32_get(next,nd,c14); λn. @trie32_get(next,nd,c15)
    }(slot)
}

@trie32_set = λ&key. λ&val. λ&depth. λ{
  #HL: λold. #HL{val};
  #HE: λ{
    0: #HL{val};
    λn.
      ! &slot = key % 32;
      ! &next = key / 32;
      ! &nd = depth - 1;
      ! &leaf = @trie32_set(next, val, nd, #HE{});
      ! &lo_slot = slot % 16;
      ! &inner = @trie_set_slot(lo_slot, leaf);
      λ{0:
        #H32{#HE{}, inner};
      λn.
        #H32{inner, #HE{}}
      }(slot < 16)
  }(depth);
  #H32: λ&lo. λ&hi.
    ! &slot = key % 32;
    ! &next = key / 32;
    ! &nd = depth - 1;
    λ{0:
      #H32{lo, @trie32_set_h(next, val, nd, slot - 16, hi)};
    λn.
      #H32{@trie32_set_h(next, val, nd, slot, lo), hi}
    }(slot < 16)
}

@trie32_set_h = λ&next. λ&val. λ&nd. λ&slot. λ{
  #HE: @trie_set_slot(slot, @trie32_set(next, val, nd, #HE{}));
  #H: λ&c0.λ&c1.λ&c2.λ&c3.λ&c4.λ&c5.λ&c6.λ&c7.λ&c8.λ&c9.λ&c10.λ&c11.λ&c12.λ&c13.λ&c14.λ&c15.
    λ{
      0:  #H{@trie32_set(next,val,nd,c0),c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15};
      1:  #H{c0,@trie32_set(next,val,nd,c1),c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15};
      2:  #H{c0,c1,@trie32_set(next,val,nd,c2),c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15};
      3:  #H{c0,c1,c2,@trie32_set(next,val,nd,c3),c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15};
      4:  #H{c0,c1,c2,c3,@trie32_set(next,val,nd,c4),c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15};
      5:  #H{c0,c1,c2,c3,c4,@trie32_set(next,val,nd,c5),c6,c7,c8,c9,c10,c11,c12,c13,c14,c15};
      6:  #H{c0,c1,c2,c3,c4,c5,@trie32_set(next,val,nd,c6),c7,c8,c9,c10,c11,c12,c13,c14,c15};
      7:  #H{c0,c1,c2,c3,c4,c5,c6,@trie32_set(next,val,nd,c7),c8,c9,c10,c11,c12,c13,c14,c15};
      8:  #H{c0,c1,c2,c3,c4,c5,c6,c7,@trie32_set(next,val,nd,c8),c9,c10,c11,c12,c13,c14,c15};
      9:  #H{c0,c1,c2,c3,c4,c5,c6,c7,c8,@trie32_set(next,val,nd,c9),c10,c11,c12,c13,c14,c15};
      10: #H{c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,@trie32_set(next,val,nd,c10),c11,c12,c13,c14,c15};
      11: #H{c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,@trie32_set(next,val,nd,c11),c12,c13,c14,c15};
      12: #H{c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,@trie32_set(next,val,nd,c12),c13,c14,c15};
      13: #H{c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,@trie32_set(next,val,nd,c13),c14,c15};
      14: #H{c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,@trie32_set(next,val,nd,c14),c15};
      λn. #H{c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,@trie32_set(next,val,nd,c15)}
    }(slot)
}

// ---- min ----

@min = λ&a. λ&b. λ{0: b; λn. a}(a < b)

// ---- foldl ----

@foldl = λ&f. λ&acc. λ{[]: acc; <>: λh. λt. @foldl(f, f(acc, h), t)}

// ---- forward adjacency ----

@fwd_adj = λ{
  0: [#E{1, 2}, #E{2, 6}];
  1: [#E{2, 3}, #E{3, 5}];
  2: [#E{4, 4}];
  3: [#E{4, 2}, #E{5, 8}];
  4: [#E{5, 1}];
  λn. []
}

// ---- backward adjacency ----

@bwd_adj = λ{
  5: [#E{4, 1}, #E{3, 8}];
  4: [#E{2, 4}, #E{3, 2}];
  3: [#E{1, 5}];
  2: [#E{0, 6}, #E{1, 3}];
  1: [#E{0, 2}];
  λn. []
}

// ---- relax_edges using radix-32 trie ----

@relax_edges = λ&src_d. λ&dist. λ{
  []: dist;
  <>: λh. λ&t. λ{
    #E: λ&tgt. λw.
      ! &new_d = src_d + w;
      ! &old_d = @trie32_get(tgt, @DEPTH, dist);
      λ{0: @relax_edges(src_d, dist, t);
         λn. @relax_edges(src_d, @trie32_set(tgt, new_d, @DEPTH, dist), t)
      }(new_d < old_d)
  }(h)
}

// ---- process_node ----

@process_node = λ&adj_fn. λ&dist. λ&node.
  ! &d = @trie32_get(node, @DEPTH, dist);
  λ{0: @relax_edges(d, dist, adj_fn(node)); λn. dist}(d == @INF)

// ---- forward pass ----

@fwd_nodes = [0, 1, 2, 3, 4, 5]

@fwd_dist = @foldl(λ&dist. λnode. @process_node(@fwd_adj, dist, node), @trie32_set(0, 0, @DEPTH, #HE{}), @fwd_nodes)

// ---- backward pass ----

@bwd_nodes = [5, 4, 3, 2, 1, 0]

@bwd_dist = @foldl(λ&dist. λnode. @process_node(@bwd_adj, dist, node), @trie32_set(5, 0, @DEPTH, #HE{}), @bwd_nodes)

// ---- meet ----

@all_nodes = [0, 1, 2, 3, 4, 5]

@meet = λ&fd. λ&bd.
  @foldl(
    λ&best. λ&v.
      ! &df = @trie32_get(v, @DEPTH, fd);
      ! &db = @trie32_get(v, @DEPTH, bd);
      @min(best, df + db),
    @INF,
    @all_nodes)

@main = @meet(@fwd_dist, @bwd_dist)
//10
