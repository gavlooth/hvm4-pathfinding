// Bellman-Ford SSSP using radix-32 trie distance table.
//
// Same graph as path_bellman_ford_trie.hvm4 but uses radix-32
// (#H32{lo,hi} wrapping two #H{...} nodes) for benchmarking
// against radix-16.
//
// Graph (5 nodes, directed, weighted):
//   0 -> 1 (weight 4)
//   0 -> 2 (weight 2)
//   1 -> 3 (weight 3)
//   2 -> 1 (weight 1)
//   2 -> 3 (weight 5)
//   3 -> 4 (weight 1)
//
// Expected: [0,3,2,6,7]
//
// DEPTH = 1 (ceil(log32(5)) = 1, since 32^1 = 32 >= 5)

// ---- constants ----

@INF = 999999
@DEPTH = 1

// ---- trie_set_slot: create a fresh 16-way node with one child set ----
// (shared helper used internally by radix-32 set)

@trie_set_slot = λ&slot. λ&child. λ{
  0:  #H{child,#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{}};
  1:  #H{#HE{},child,#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{}};
  2:  #H{#HE{},#HE{},child,#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{}};
  3:  #H{#HE{},#HE{},#HE{},child,#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{}};
  4:  #H{#HE{},#HE{},#HE{},#HE{},child,#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{}};
  5:  #H{#HE{},#HE{},#HE{},#HE{},#HE{},child,#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{}};
  6:  #H{#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},child,#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{}};
  7:  #H{#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},child,#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{}};
  8:  #H{#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},child,#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{}};
  9:  #H{#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},child,#HE{},#HE{},#HE{},#HE{},#HE{},#HE{}};
  10: #H{#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},child,#HE{},#HE{},#HE{},#HE{},#HE{}};
  11: #H{#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},child,#HE{},#HE{},#HE{},#HE{}};
  12: #H{#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},child,#HE{},#HE{},#HE{}};
  13: #H{#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},child,#HE{},#HE{}};
  14: #H{#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},child,#HE{}};
  λn. #H{#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},#HE{},child}
}(slot)

// ---- radix-32 trie ----
// #H32{lo, hi} wraps two #H{...} nodes for 32-way branching

@trie32_get = λ&key. λ&depth. λ{
  #HE: @INF;
  #HL: λval. val;
  #H32: λ&lo. λ&hi.
    ! &slot = key % 32;
    ! &next = key / 32;
    ! &nd = depth - 1;
    λ{0:
      @trie32_get_h(next, nd, slot - 16, hi);
    λn.
      @trie32_get_h(next, nd, slot, lo)
    }(slot < 16)
}

@trie32_get_h = λ&next. λ&nd. λ&slot. λ{
  #HE: @INF;
  #H: λc0.λc1.λc2.λc3.λc4.λc5.λc6.λc7.λc8.λc9.λc10.λc11.λc12.λc13.λc14.λc15.
    λ{
      0:  @trie32_get(next,nd,c0);  1:  @trie32_get(next,nd,c1);
      2:  @trie32_get(next,nd,c2);  3:  @trie32_get(next,nd,c3);
      4:  @trie32_get(next,nd,c4);  5:  @trie32_get(next,nd,c5);
      6:  @trie32_get(next,nd,c6);  7:  @trie32_get(next,nd,c7);
      8:  @trie32_get(next,nd,c8);  9:  @trie32_get(next,nd,c9);
      10: @trie32_get(next,nd,c10); 11: @trie32_get(next,nd,c11);
      12: @trie32_get(next,nd,c12); 13: @trie32_get(next,nd,c13);
      14: @trie32_get(next,nd,c14); λn. @trie32_get(next,nd,c15)
    }(slot)
}

@trie32_set = λ&key. λ&val. λ&depth. λ{
  #HL: λold. #HL{val};
  #HE: λ{
    0: #HL{val};
    λn.
      ! &slot = key % 32;
      ! &next = key / 32;
      ! &nd = depth - 1;
      ! &leaf = @trie32_set(next, val, nd, #HE{});
      ! &lo_slot = slot % 16;
      ! &inner = @trie_set_slot(lo_slot, leaf);
      λ{0:
        #H32{#HE{}, inner};
      λn.
        #H32{inner, #HE{}}
      }(slot < 16)
  }(depth);
  #H32: λ&lo. λ&hi.
    ! &slot = key % 32;
    ! &next = key / 32;
    ! &nd = depth - 1;
    λ{0:
      #H32{lo, @trie32_set_h(next, val, nd, slot - 16, hi)};
    λn.
      #H32{@trie32_set_h(next, val, nd, slot, lo), hi}
    }(slot < 16)
}

@trie32_set_h = λ&next. λ&val. λ&nd. λ&slot. λ{
  #HE: @trie_set_slot(slot, @trie32_set(next, val, nd, #HE{}));
  #H: λ&c0.λ&c1.λ&c2.λ&c3.λ&c4.λ&c5.λ&c6.λ&c7.λ&c8.λ&c9.λ&c10.λ&c11.λ&c12.λ&c13.λ&c14.λ&c15.
    λ{
      0:  #H{@trie32_set(next,val,nd,c0),c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15};
      1:  #H{c0,@trie32_set(next,val,nd,c1),c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15};
      2:  #H{c0,c1,@trie32_set(next,val,nd,c2),c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15};
      3:  #H{c0,c1,c2,@trie32_set(next,val,nd,c3),c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15};
      4:  #H{c0,c1,c2,c3,@trie32_set(next,val,nd,c4),c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15};
      5:  #H{c0,c1,c2,c3,c4,@trie32_set(next,val,nd,c5),c6,c7,c8,c9,c10,c11,c12,c13,c14,c15};
      6:  #H{c0,c1,c2,c3,c4,c5,@trie32_set(next,val,nd,c6),c7,c8,c9,c10,c11,c12,c13,c14,c15};
      7:  #H{c0,c1,c2,c3,c4,c5,c6,@trie32_set(next,val,nd,c7),c8,c9,c10,c11,c12,c13,c14,c15};
      8:  #H{c0,c1,c2,c3,c4,c5,c6,c7,@trie32_set(next,val,nd,c8),c9,c10,c11,c12,c13,c14,c15};
      9:  #H{c0,c1,c2,c3,c4,c5,c6,c7,c8,@trie32_set(next,val,nd,c9),c10,c11,c12,c13,c14,c15};
      10: #H{c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,@trie32_set(next,val,nd,c10),c11,c12,c13,c14,c15};
      11: #H{c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,@trie32_set(next,val,nd,c11),c12,c13,c14,c15};
      12: #H{c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,@trie32_set(next,val,nd,c12),c13,c14,c15};
      13: #H{c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,@trie32_set(next,val,nd,c13),c14,c15};
      14: #H{c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,@trie32_set(next,val,nd,c14),c15};
      λn. #H{c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,@trie32_set(next,val,nd,c15)}
    }(slot)
}

// ---- min ----

@min = λ&a. λ&b. λ{0: b; λn. a}(a < b)

// ---- edge list ----

@edges = [#E3{0,1,4}, #E3{0,2,2}, #E3{1,3,3}, #E3{2,1,1}, #E3{2,3,5}, #E3{3,4,1}]

// ---- relax one edge using radix-32 trie ----

@relax_edge = λ&dist. λ{
  #E3: λ&u. λ&v. λw.
    ! &du = @trie32_get(u, @DEPTH, dist);
    ! &new_d = du + w;
    ! &dv = @trie32_get(v, @DEPTH, dist);
    λ{0: dist; λn. @trie32_set(v, new_d, @DEPTH, dist)}(new_d < dv)
}

// ---- foldl ----

@foldl = λ&f. λ&acc. λ{[]: acc; <>: λh. λt. @foldl(f, f(acc, h), t)}

// ---- relax all edges ----

@relax_round = λdist. @foldl(@relax_edge, dist, @edges)

// ---- repeat ----

@repeat = λ&f. λ&x. λ{0: x; λn. @repeat(f, f(x), n - 1)}

// ---- initial distance table: source 0 has distance 0 ----

@init_dist = @trie32_set(0, 0, @DEPTH, #HE{})

// ---- run Bellman-Ford: V-1 = 4 rounds ----

@bf = @repeat(@relax_round, @init_dist, 4)

// ---- extract results ----

@main = [
  @trie32_get(0, @DEPTH, @bf),
  @trie32_get(1, @DEPTH, @bf),
  @trie32_get(2, @DEPTH, @bf),
  @trie32_get(3, @DEPTH, @bf),
  @trie32_get(4, @DEPTH, @bf)]
//[0,3,2,6,7]
