// Delta-stepping single-source shortest path algorithm (simplified).
//
// Delta-stepping classifies edges by weight relative to a threshold delta:
//   light edges: weight <= delta  (relaxed repeatedly within a bucket)
//   heavy edges: weight > delta   (relaxed once per bucket round)
//
// Each round relaxes light edges multiple times (intra-bucket propagation),
// then relaxes heavy edges once (inter-bucket step). After enough rounds,
// the distance table converges to shortest paths.
//
// This simplified version uses association-list distance tables and a fixed
// number of rounds, equivalent to full delta-stepping on small graphs.
//
// Graph (5 nodes, 0-4, directed, weighted):
//   0 -> 1 (weight 1)  [light]
//   0 -> 2 (weight 5)  [heavy]
//   1 -> 2 (weight 2)  [light]
//   1 -> 3 (weight 6)  [heavy]
//   2 -> 3 (weight 2)  [light]
//   2 -> 4 (weight 1)  [light]
//   3 -> 4 (weight 3)  [light, weight == delta]
//
// Delta = 3
//
// Shortest distances from source node 0:
//   dist[0] = 0
//   dist[1] = 1  (0->1)
//   dist[2] = 3  (0->1->2: 1+2)
//   dist[3] = 5  (0->1->2->3: 1+2+2)
//   dist[4] = 4  (0->1->2->4: 1+2+1)

// ---- constants ----

@INF = 999999
@DELTA = 3

// ---- association list: list of #KV{key, value} pairs ----

// assoc_get(key, default, alist): lookup key, return value or default
@assoc_get = λ&key. λ&default. λ{
  []: default;
  <>: λh. λt. λ{
    #KV: λ&k. λv. λ{0: @assoc_get(key, default, t); λn. v}(k == key)
  }(h)
}

// assoc_set(key, value, alist): update existing or prepend new pair
@assoc_set = λ&key. λ&val. λ{
  []: [#KV{key, val}];
  <>: λ&h. λ&t. λ{
    #KV: λ&k. λv. λ{
      0: h <> @assoc_set(key, val, t);
      λn. #KV{k, val} <> t
    }(k == key)
  }(h)
}

// ---- min ----

@min = λ&a. λ&b. λ{0: b; λn. a}(a < b)

// ---- edge relaxation ----

// relax_edge(dist, #E3{u, v, w}): if dist[u]+w < dist[v], update dist[v]
@relax_edge = λ&dist. λ{
  #E3: λ&u. λ&v. λw.
    ! &du = @assoc_get(u, @INF, dist);
    ! &new_d = du + w;
    ! &dv = @assoc_get(v, @INF, dist);
    λ{0: dist; λn. @assoc_set(v, new_d, dist)}(new_d < dv)
}

// relax_list(dist, edges): fold over edge list, threading distance table
@relax_list = λ&dist. λ{
  []: dist;
  <>: λh. λt. @relax_list(@relax_edge(dist, h), t)
}

// ---- repeat ----

// repeat(f, x, n): apply f to x, n times
@repeat = λ&f. λ&x. λ{0: x; λn. @repeat(f, f(x), n - 1)}

// ---- edge classification (delta = 3) ----

// Light edges: weight <= delta
@light_edges = [
  #E3{0, 1, 1},
  #E3{1, 2, 2},
  #E3{2, 3, 2},
  #E3{2, 4, 1},
  #E3{3, 4, 3}]

// Heavy edges: weight > delta
@heavy_edges = [
  #E3{0, 2, 5},
  #E3{1, 3, 6}]

// ---- one delta-stepping round ----
// Relax light edges twice (intra-bucket propagation), then heavy edges once
@one_round = λdist.
  ! &d1 = @relax_list(dist, @light_edges);
  ! &d2 = @relax_list(d1, @light_edges);
  @relax_list(d2, @heavy_edges)

// ---- initial distance table: source 0 has distance 0 ----
@init_dist = [#KV{0, 0}]

// ---- run 4 rounds of delta-stepping (V-1 rounds suffice) ----
@result = @repeat(@one_round, @init_dist, 4)

// ---- extract results ----
@main = [
  @assoc_get(0, @INF, @result),
  @assoc_get(1, @INF, @result),
  @assoc_get(2, @INF, @result),
  @assoc_get(3, @INF, @result),
  @assoc_get(4, @INF, @result)]
//[0,1,3,5,4]
