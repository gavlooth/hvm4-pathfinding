// Delta-stepping SSSP using linear binary trie + early termination.
//
// Combines the delta-stepping algorithm structure (light/heavy edge phases)
// with a linear binary trie for O(log2(V)) distance storage and early
// termination to stop when no distances change in a complete round.
//
// Delta-stepping classifies edges by weight relative to a threshold delta:
//   light edges: weight <= delta  (relaxed repeatedly within a bucket)
//   heavy edges: weight > delta   (relaxed once per bucket round)
//
// Each round relaxes light edges twice (intra-bucket propagation), then
// heavy edges once (inter-bucket step). Iteration stops early when a
// full round (light+light+heavy) produces zero distance changes.
//
// Graph (5 nodes, 0-4, directed, weighted):
//   0 -> 1 (weight 1)  [light]
//   0 -> 2 (weight 5)  [heavy]
//   1 -> 2 (weight 2)  [light]
//   1 -> 3 (weight 6)  [heavy]
//   2 -> 3 (weight 2)  [light]
//   2 -> 4 (weight 1)  [light]
//   3 -> 4 (weight 3)  [light, weight == delta]
//
// Delta = 3
//
// Shortest distances from source node 0:
//   dist[0] = 0
//   dist[1] = 1  (0->1)
//   dist[2] = 3  (0->1->2: 1+2)
//   dist[3] = 5  (0->1->2->3: 1+2+2)
//   dist[4] = 4  (0->1->2->4: 1+2+1)
//
// DEPTH = 3 (ceil(log2(5)) = 3, since 2^3 = 8 >= 5)

// ---- constants ----

@INF = 999999
@DELTA = 3
@DEPTH = 3

// ---- linear binary trie functions (inlined) ----

// btrie_get_lin: linear GET returning #P{val, rebuilt_trie}
// Consumes the trie and rebuilds it — no cloning of trie nodes.

@btrie_get_lin = λ&key. λ&depth. λ{
  #BE: #P{@INF, #BE{}};
  #BL: λ&val. #P{val, #BL{val}};
  #B: λl. λr.
    ! bit = key % 2;
    ! next = key / 2;
    ! nd = depth - 1;
    @btrie_get_lin_B(bit, next, nd, l, r)
}

@btrie_get_lin_B = λ{
  0: λnext. λnd. λl. λr.
    λ{#P: λval. λnew_l. #P{val, #B{new_l, r}}}(@btrie_get_lin(next, nd, l));
  λn. λnext. λnd. λl. λr.
    λ{#P: λval. λnew_r. #P{val, #B{l, new_r}}}(@btrie_get_lin(next, nd, r))
}

// btrie_get: destructive GET (for final extraction only)
// Consumes the trie without rebuilding.

@btrie_get = λ&key. λ&depth. λ{
  #BE: @INF;
  #BL: λval. val;
  #B: λl. λr.
    ! bit = key % 2;
    ! next = key / 2;
    ! nd = depth - 1;
    @btrie_get_B(bit, next, nd, l, r)
}

@btrie_get_B = λ{
  0: λnext. λnd. λl. λr. @btrie_get(next, nd, l);
  λn. λnext. λnd. λl. λr. @btrie_get(next, nd, r)
}

// btrie_set: linear SET

@btrie_set = λ&key. λ&val. λ&depth. λ{
  #BL: λold. #BL{val};
  #BE: λ{
    0: #BL{val};
    λn.
      ! &bit = key % 2;
      ! &next = key / 2;
      ! &nd = depth - 1;
      @btrie_set_BE(bit, next, val, nd)
  }(depth);
  #B: λl. λr.
    ! bit = key % 2;
    ! next = key / 2;
    ! nd = depth - 1;
    @btrie_set_B(bit, next, val, nd, l, r)
}

@btrie_set_BE = λ{
  0: λnext. λval. λnd. #B{@btrie_set(next, val, nd, #BE{}), #BE{}};
  λn. λnext. λval. λnd. #B{#BE{}, @btrie_set(next, val, nd, #BE{})}
}

@btrie_set_B = λ{
  0: λnext. λval. λnd. λl. λr. #B{@btrie_set(next, val, nd, l), r};
  λn. λnext. λval. λnd. λl. λr. #B{l, @btrie_set(next, val, nd, r)}
}

// btrie_min_update_f: linear MIN-UPDATE with change flag
// Returns #P{new_trie, changed} where changed is 0 or 1.

@btrie_min_update_f = λ&key. λ&val. λ&depth. λ{
  #BL: λ&old. λ{0: #P{#BL{old}, 0}; λn. #P{#BL{val}, 1}}(val < old);
  #BE: λ{
    0: #P{#BL{val}, 1};
    λn.
      ! &bit = key % 2;
      ! &next = key / 2;
      ! &nd = depth - 1;
      @btrie_muf_BE(bit, next, val, nd)
  }(depth);
  #B: λl. λr.
    ! bit = key % 2;
    ! next = key / 2;
    ! nd = depth - 1;
    @btrie_muf_B(bit, next, val, nd, l, r)
}

@btrie_muf_BE = λ{
  0: λnext. λval. λnd.
    λ{#P: λchild. λc. #P{#B{child, #BE{}}, c}}(@btrie_min_update_f(next, val, nd, #BE{}));
  λn. λnext. λval. λnd.
    λ{#P: λchild. λc. #P{#B{#BE{}, child}, c}}(@btrie_min_update_f(next, val, nd, #BE{}))
}

@btrie_muf_B = λ{
  0: λnext. λval. λnd. λl. λr.
    λ{#P: λnew_l. λc. #P{#B{new_l, r}, c}}(@btrie_min_update_f(next, val, nd, l));
  λn. λnext. λval. λnd. λl. λr.
    λ{#P: λnew_r. λc. #P{#B{l, new_r}, c}}(@btrie_min_update_f(next, val, nd, r))
}

// ---- edge classification (delta = 3) ----

// Light edges: weight <= delta
@light_edges = [
  #E3{0, 1, 1},
  #E3{1, 2, 2},
  #E3{2, 3, 2},
  #E3{2, 4, 1},
  #E3{3, 4, 3}]

// Heavy edges: weight > delta
@heavy_edges = [
  #E3{0, 2, 5},
  #E3{1, 3, 6}]

// ---- early termination edge relaxation ----
// State: #S{dist, changed} wraps the trie + change counter.
// Each edge relaxation unpacks state, does a linear get, conditionally
// updates via btrie_min_update_f, and repacks state with accumulated changes.

@relax_edge_et = λ{
  #S: λdist. λ&changed. λ{
    #E3: λu. λv. λw.
      λ{#P: λ&du. λdist2.
        ! new_d = du + w;
        @relax_cond_et(du < @INF, v, new_d, dist2, changed)
      }(@btrie_get_lin(u, @DEPTH, dist))
  }
}

@relax_cond_et = λ{
  0: λv. λnew_d. λdist. λchanged. #S{dist, changed};
  λn. λv. λnew_d. λdist. λ&changed.
    λ{#P: λnew_dist. λc. #S{new_dist, changed + c}}(@btrie_min_update_f(v, new_d, @DEPTH, dist))
}

// ---- linear fold for early termination ----

@foldl_et = λf. λacc. λlist. @foldl_et_go(list, f, acc)

@foldl_et_go = λ{
  []: λf. λacc. acc;
  <>: λh. λt. λ&f. λacc. @foldl_et_go(t, f, f(acc, h))
}

// ---- one delta-stepping round with early termination ----
// One round = relax light edges (fold) -> relax light edges again (fold)
//          -> relax heavy edges (fold)
// The #S{dist, changed} state is threaded through ALL three phases.
// Changes are summed across all three sub-folds.
// The round resets the change counter to 0 at the start, discarding
// the old counter from the previous round.

@one_round_et = λ{
  #S: λdist. λold_changed.
    ! s1 = @foldl_et(@relax_edge_et, #S{dist, 0}, @light_edges);
    @one_round_et_2(s1)
}

@one_round_et_2 = λ{
  #S: λdist. λchanged1.
    ! s2 = @foldl_et(@relax_edge_et, #S{dist, changed1}, @light_edges);
    @one_round_et_3(s2)
}

@one_round_et_3 = λ{
  #S: λdist. λchanged2.
    @foldl_et(@relax_edge_et, #S{dist, changed2}, @heavy_edges)
}

// ---- repeat_until: stop when changed == 0 ----

@repeat_until = λf. λx. λn. @repeat_until_go(n, f, x)

@repeat_until_go = λ{
  0: λf. λx. x;
  λn. λ&f. λstate.
    @check_continue(n, f, f(state))
}

@check_continue = λ&n. λ&f. λ{
  #S: λdist. λchanged.
    @check_go(changed, n, f, dist)
}

@check_go = λ{
  0: λn. λf. λdist. #S{dist, 0};
  λm. λn. λf. λdist. @repeat_until_go(n - 1, f, #S{dist, 1})
}

// ---- initial state: dist[0]=0, changed=1 (to start first round) ----

@init_dist = @btrie_set(0, 0, @DEPTH, #BE{})
@init_state = #S{@init_dist, 1}

// ---- run: max 4 rounds (V-1), but will stop early if no changes ----

@result = @repeat_until(@one_round_et, @init_state, 4)

// ---- extract results (chain linear gets, final destructive get) ----

@extract = λ{#S: λdist. λc.
  λ{#P: λ&d0. λdist.
  λ{#P: λ&d1. λdist.
  λ{#P: λ&d2. λdist.
  λ{#P: λ&d3. λdist.
    ! d4 = @btrie_get(4, @DEPTH, dist);
    [d0, d1, d2, d3, d4]
  }(@btrie_get_lin(3, @DEPTH, dist))
  }(@btrie_get_lin(2, @DEPTH, dist))
  }(@btrie_get_lin(1, @DEPTH, dist))
  }(@btrie_get_lin(0, @DEPTH, dist))
}

@main = @extract(@result)
//[0,1,3,5,4]
